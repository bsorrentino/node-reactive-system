{"version":3,"file":"component.js","sources":["../src/rx/endlessSubject.js","../src/rx/endlessReplaySubject.js","../src/utils/compareTopics.js","../src/utils/findTopicByName.js","../src/channel.js","../src/rxmq.js","../index.js"],"sourcesContent":["/* eslint no-param-reassign: [2, {\"props\": false}] */\nimport { Subject } from 'rxjs';\n\n/**\n * EndlessSubject extension of Rx.Subject.\n * This is pretty hacky, but so far I'd found no better way of having\n * Subjects that do no close on multicasted stream completion and on multiple errors.\n * For documentation refer to\n * [Rx.Subject docs](@link https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md).\n * The only difference is that EndlessSubject never triggers '.complete()' and\n * does not closes observers on errors (thus allowing to continuously dispatch them).\n */\nclass EndlessSubject extends Subject {\n  /**\n   * Dummy method override to prevent execution and Rx.Observable completion\n   * @return {void}\n   */\n  complete() {}\n\n  /**\n   * Override of error method that prevents stopping that Rx.Observer\n   * @param  {Error} error  - Error to be dispatched\n   * @return {void}\n   */\n  error(error) {\n    this.thrownError = error;\n    // dispatch to all observers\n    // eslint-disable-next-line prettier/prettier\n    this.observers.forEach( os => os.error( error ) );\n\n    // THERE IS AN ERROR ON ORIGINAL CODE BELOW\n    // this.observers.forEach(os => {\n    //   // dispatch directly to destination\n    //   os.destination._error.call(os.destination._context, error);\n    // });\n  }\n}\n\nexport { EndlessSubject };\n","/* eslint no-param-reassign: [2, {\"props\": false}] */\nimport { ReplaySubject } from 'rxjs';\n\n/**\n * EndlessReplaySubject extension of ReplaySubject.\n * This is pretty hacky, but so far I'd found no better way of having\n * Subjects that do no close on multicasted stream completion and on multiple errors.\n * For documentation refer to\n * [ReplaySubject doc](@link https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/replaysubject.md).\n * The only difference is that EndlessReplaySubject never triggers '.complete()' and\n * does not closes observers on errors (thus allowing to continuously dispatch them).\n */\nclass EndlessReplaySubject extends ReplaySubject {\n  /**\n   * Dummy method override to prevent execution and Observable completion\n   * @return {void}\n   */\n  complete() {}\n\n  /**\n   * Override of error method that prevents stopping that Observer\n   * @param  {Error} error  - Error to be dispatched\n   * @return {void}\n   */\n  error(error) {\n    // store error\n    this.error = error;\n    // dispatch to all observers\n    this.observers.forEach(os => {\n      // dispatch\n      os.error(error);\n      // mark observer as not stopped\n      os.isStopped = false;\n    });\n  }\n}\n\nexport { EndlessReplaySubject };\n","/**\n * Converts topic to search regex\n * @param  {String} topic   Topic name\n * @return {Regex}          Search regex\n * @private\n */\nconst topicToRegex = topic =>\n  `^${topic.split('.').reduce((result, segment, index, arr) => {\n    let res = '';\n    if (arr[index - 1]) {\n      res = arr[index - 1] !== '#' ? '\\\\.\\\\b' : '\\\\b';\n    }\n    if (segment === '#') {\n      res += '[\\\\s\\\\S]*';\n    } else if (segment === '*') {\n      res += '[^.]+';\n    } else {\n      res += segment;\n    }\n    return result + res;\n  }, '')}$`;\n\n/**\n * Compares given topic with existing topic\n * @param  {String}  topic         Topic name\n * @param  {String}  existingTopic Topic name to compare to\n * @return {Boolean}               Whether topic is included in existingTopic\n * @example\n * should(compareTopics('test.one.two', 'test.#')).equal(true);\n * @private\n */\nconst compareTopics = (topic, existingTopic) => {\n  // if no # or * found, do plain string matching\n  if (existingTopic.indexOf('#') === -1 && existingTopic.indexOf('*') === -1) {\n    return topic === existingTopic;\n  }\n  // otherwise do regex matching\n  const pattern = topicToRegex(existingTopic);\n  const rgx = new RegExp(pattern);\n  const result = rgx.test(topic);\n  return result;\n};\n\nexport { compareTopics };\n","/**\n * Find a specific subject by given name\n * @param  {Array}                  subjects    Array of subjects to search in\n * @param  {String}                 name        Name to search for\n * @return {(EndlessSubject|void)}              Found subject or void\n */\nconst findSubjectByName = (subjects, name) => {\n  const res = subjects.filter(s => s.name === name);\n  if (!res || res.length < 1) {\n    return undefined;\n  }\n\n  return res[0];\n};\n\nexport { findSubjectByName };\n","import { AsyncSubject, NEVER } from 'rxjs';\nimport { filter, mergeAll } from 'rxjs/operators';\nimport { EndlessReplaySubject, EndlessSubject } from './rx/index';\nimport { compareTopics, findSubjectByName } from './utils/index';\n\n// const channelName = Symbol('channel.name');\n// const channelData = Symbol('channel.data');\n/**\n * Rxmq channel class\n */\nclass Channel {\n  /**\n   * Represents a new Rxmq channel.\n   * Normally you wouldn't need to instantiate it directly, you'd just work with existing instance.\n   * @constructor\n   * @return {void}\n   */\n  constructor() {\n    /**\n     * Internal set of utilities\n     * @type {Object}\n     * @private\n     */\n    this.utils = {\n      findSubjectByName,\n      compareTopics,\n    };\n\n    /**\n     * Instances of subjects\n     * @type {Array}\n     * @private\n     */\n    this.subjects = [];\n    /**\n     * Channel bus\n     * @type {EndlessReplaySubject}\n     * @private\n     */\n    this.channelBus = new EndlessReplaySubject();\n    /**\n     * Permanent channel bus stream as Observable\n     * @type {Observable}\n     * @private\n     */\n    this.channelStream = this.channelBus;\n  }\n\n  /**\n   * Returns EndlessSubject representing given topic\n   * @param  {String}         name           Topic name\n   * @return {EndlessSubject}             EndlessSubject representing given topic\n   * @example\n   * const channel = rxmq.channel('test');\n   * const subject = channel.subject('test.topic');\n   */\n  subject(name, { Subject = EndlessSubject } = {}) {\n    let s = this.utils.findSubjectByName(this.subjects, name);\n    if (!s) {\n      console.log('add proxy for ', name);\n      s = new Proxy(new Subject(), {\n        get(target, propKey, receiver) {\n          if (propKey === 'next') {\n            const origMethod = target[propKey];\n            return function (...args) {\n              const params = [];\n              if (\n                typeof args[0] === 'string' ||\n                typeof args[0] === 'number' ||\n                typeof args[0] === 'boolean' ||\n                args[0] instanceof Date\n              ) {\n                params.push({ channel: name, data: args[0] });\n              } else {\n                params.push({ channel: name, ...args[0] });\n              }\n              const result = origMethod.apply(this, params);\n              // console.log(name, propKey, JSON.stringify(params), JSON.stringify(result));\n              return result;\n            };\n          } else return Reflect.get(...arguments);\n        },\n      });\n      // s = new Subject();\n      s.name = name;\n      this.subjects.push(s);\n      this.channelBus.next(s);\n    }\n    return s;\n  }\n\n  /**\n   * Get an Observable for specific set of topics\n   * @param  {String}         name        Topic name / pattern\n   * @return {Observable}                 Observable for given set of topics\n   * @example\n   * const channel = rxmq.channel('test');\n   * channel.observe('test.topic')\n   *        .subscribe((res) => { // default Observable subscription\n   *            // handle results\n   *        });\n   */\n  observe(name) {\n    // create new topic if it's plain text\n    if (name.indexOf('#') === -1 && name.indexOf('*') === -1) {\n      return this.subject(name);\n    }\n    // return stream\n    return this.channelStream.pipe(\n      filter(obs => compareTopics(obs.name, name)),\n      mergeAll()\n    );\n  }\n\n  /**\n   * Do a request that will be replied into returned AsyncSubject\n   * Alias for '.request()' that uses single object as params\n   * @param  {Object}  options                   Request options\n   * @param  {String}  options.topic             Topic name\n   * @param  {Any}     options.data              Request data\n   * @param  {Object}  options.DefaultSubject    Response subject, defaults to AsyncSubject\n   * @return {AsyncSubject}                      AsyncSubject that will dispatch the response\n   * @example\n   * const channel = rxmq.channel('test');\n   * channel.requestTo({\n   *     topic: 'test.topic',\n   *     data: 'test data',\n   * }).subscribe((response) => { // default Observable subscription\n   *     // handle response\n   * });\n   */\n  request({ topic, data, Subject = AsyncSubject }) {\n    const subj = this.utils.findSubjectByName(this.subjects, topic);\n    if (!subj) {\n      return NEVER;\n    }\n\n    // create reply subject\n    const replySubject = new Subject();\n    subj.next({ replySubject, data });\n    return replySubject;\n  }\n}\n\n/**\n * Channel definition\n */\nexport default Channel;\n","import Channel from './channel';\n\n/**\n * Rxmq message bus class\n */\nclass Rxmq {\n  /**\n   * Represents a new Rxmq message bus.\n   * Normally you'd just use a signleton returned by default, but it's also\n   * possible to create a new instance of Rxmq should you need it.\n   * @constructor\n   * @example\n   * import {Rxmq} from 'rxmq';\n   * const myRxmq = new Rxmq();\n   */\n  constructor() {\n    /**\n     * Holds channels definitions\n     * @type {Object}\n     * @private\n     */\n    this.channels = {};\n  }\n\n  /**\n   * Returns a channel names\n   */\n  channelNames() {\n    return Object.keys(this.channels);\n  }\n\n  /**\n   * Returns a channel for given name\n   * @param  {String} name  Channel name\n   * @return {Channel}      Channel object\n   * @example\n   * const testChannel = rxmq.channel('test');\n   */\n  channel(name = 'defaultRxmqChannel') {\n    if (!this.channels[name]) {\n      this.channels[name] = new Channel();\n    }\n\n    return this.channels[name];\n  }\n}\n\n/**\n * Rxmq bus definition\n */\nexport default Rxmq;\n","import RxMQ from './src/index';\n\nexport { EndlessSubject, EndlessReplaySubject, Channel } from './src/index';\nexport default new RxMQ();\n"],"names":["EndlessSubject","error","thrownError","observers","forEach","os","Subject","EndlessReplaySubject","isStopped","ReplaySubject","topicToRegex","topic","split","reduce","result","segment","index","arr","res","compareTopics","existingTopic","indexOf","pattern","rgx","RegExp","test","findSubjectByName","subjects","name","filter","s","length","undefined","Channel","utils","channelBus","channelStream","console","log","Proxy","get","target","propKey","receiver","origMethod","params","Date","push","channel","data","apply","Reflect","arguments","next","subject","pipe","obs","mergeAll","AsyncSubject","subj","NEVER","replySubject","Rxmq","channels","Object","keys","RxMQ"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAGA;;;;;;;;;;MASMA;;;;;;;;;;;;;;EACJ;;;;iCAIW;EAEX;;;;;;;;4BAKMC,QAAO;EACX,WAAKC,WAAL,GAAmBD,MAAnB,CADW;EAGX;;EACA,WAAKE,SAAL,CAAeC,OAAf,CAAwB,UAAAC,EAAE;EAAA,eAAIA,EAAE,CAACJ,KAAH,CAAUA,MAAV,CAAJ;EAAA,OAA1B,EAJW;EAOX;EACA;EACA;EACA;EACD;;;;IAvB0BK;;ECT7B;;;;;;;;;;MASMC;;;;;;;;;;;;;;EACJ;;;;iCAIW;EAEX;;;;;;;;4BAKMN,QAAO;EACX;EACA,WAAKA,KAAL,GAAaA,MAAb,CAFW;;EAIX,WAAKE,SAAL,CAAeC,OAAf,CAAuB,UAAAC,EAAE,EAAI;EAC3B;EACAA,QAAAA,EAAE,CAACJ,KAAH,CAASA,MAAT,EAF2B;;EAI3BI,QAAAA,EAAE,CAACG,SAAH,GAAe,KAAf;EACD,OALD;EAMD;;;;IAtBgCC;;ECZnC;;;;;;EAMA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAAC,KAAK;EAAA,oBACpBA,KAAK,CAACC,KAAN,CAAY,GAAZ,EAAiBC,MAAjB,CAAwB,UAACC,MAAD,EAASC,OAAT,EAAkBC,KAAlB,EAAyBC,GAAzB,EAAiC;EAC3D,QAAIC,GAAG,GAAG,EAAV;;EACA,QAAID,GAAG,CAACD,KAAK,GAAG,CAAT,CAAP,EAAoB;EAClBE,MAAAA,GAAG,GAAGD,GAAG,CAACD,KAAK,GAAG,CAAT,CAAH,KAAmB,GAAnB,GAAyB,QAAzB,GAAoC,KAA1C;EACD;;EACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;EACnBG,MAAAA,GAAG,IAAI,WAAP;EACD,KAFD,MAEO,IAAIH,OAAO,KAAK,GAAhB,EAAqB;EAC1BG,MAAAA,GAAG,IAAI,OAAP;EACD,KAFM,MAEA;EACLA,MAAAA,GAAG,IAAIH,OAAP;EACD;;EACD,WAAOD,MAAM,GAAGI,GAAhB;EACD,GAbG,EAaD,EAbC,CADoB;EAAA,CAA1B;EAgBA;;;;;;;;;;;EASA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACR,KAAD,EAAQS,aAAR,EAA0B;EAC9C;EACA,MAAIA,aAAa,CAACC,OAAd,CAAsB,GAAtB,MAA+B,CAAC,CAAhC,IAAqCD,aAAa,CAACC,OAAd,CAAsB,GAAtB,MAA+B,CAAC,CAAzE,EAA4E;EAC1E,WAAOV,KAAK,KAAKS,aAAjB;EACD,GAJ6C;;;EAM9C,MAAME,OAAO,GAAGZ,YAAY,CAACU,aAAD,CAA5B;EACA,MAAMG,GAAG,GAAG,IAAIC,MAAJ,CAAWF,OAAX,CAAZ;EACA,MAAMR,MAAM,GAAGS,GAAG,CAACE,IAAJ,CAASd,KAAT,CAAf;EACA,SAAOG,MAAP;EACD,CAVD;;EC/BA;;;;;;EAMA,IAAMY,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,QAAD,EAAWC,IAAX,EAAoB;EAC5C,MAAMV,GAAG,GAAGS,QAAQ,CAACE,MAAT,CAAgB,UAAAC,CAAC;EAAA,WAAIA,CAAC,CAACF,IAAF,KAAWA,IAAf;EAAA,GAAjB,CAAZ;;EACA,MAAI,CAACV,GAAD,IAAQA,GAAG,CAACa,MAAJ,GAAa,CAAzB,EAA4B;EAC1B,WAAOC,SAAP;EACD;;EAED,SAAOd,GAAG,CAAC,CAAD,CAAV;EACD,CAPD;;ECAA;;EACA;;;;MAGMe;EACJ;;;;;;EAMA,qBAAc;EAAA;;EACZ;;;;;EAKA,SAAKC,KAAL,GAAa;EACXR,MAAAA,iBAAiB,EAAjBA,iBADW;EAEXP,MAAAA,aAAa,EAAbA;EAFW,KAAb;EAKA;;;;;;EAKA,SAAKQ,QAAL,GAAgB,EAAhB;EACA;;;;;;EAKA,SAAKQ,UAAL,GAAkB,IAAI5B,oBAAJ,EAAlB;EACA;;;;;;EAKA,SAAK6B,aAAL,GAAqB,KAAKD,UAA1B;EACD;EAED;;;;;;;;;;;;8BAQQP,MAAyC;EAAA,qFAAJ,EAAI;EAAA,8BAAjCtB,OAAiC;EAAA,UAAjCA,OAAiC,6BAAvBN,cAAuB;;EAC/C,UAAI8B,CAAC,GAAG,KAAKI,KAAL,CAAWR,iBAAX,CAA6B,KAAKC,QAAlC,EAA4CC,IAA5C,CAAR;;EACA,UAAI,CAACE,CAAL,EAAQ;EACNO,QAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAA8BV,IAA9B;EACAE,QAAAA,CAAC,GAAG,IAAIS,KAAJ,CAAU,IAAIjC,OAAJ,EAAV,EAAyB;EAC3BkC,UAAAA,GAD2B,eACvBC,MADuB,EACfC,OADe,EACNC,QADM,EACI;EAC7B,gBAAID,OAAO,KAAK,MAAhB,EAAwB;EACtB,kBAAME,UAAU,GAAGH,MAAM,CAACC,OAAD,CAAzB;EACA,qBAAO,YAAmB;EACxB,oBAAMG,MAAM,GAAG,EAAf;;EACA,oBACE,8DAAmB,QAAnB,IACA,8DAAmB,QADnB,IAEA,8DAAmB,SAFnB,IAGA,8DAAmBC,IAJrB,EAKE;EACAD,kBAAAA,MAAM,CAACE,IAAP,CAAY;EAAEC,oBAAAA,OAAO,EAAEpB,IAAX;EAAiBqB,oBAAAA,IAAI;EAArB,mBAAZ;EACD,iBAPD,MAOO;EACLJ,kBAAAA,MAAM,CAACE,IAAP;EAAcC,oBAAAA,OAAO,EAAEpB;EAAvB;EACD;;EACD,oBAAMd,MAAM,GAAG8B,UAAU,CAACM,KAAX,CAAiB,IAAjB,EAAuBL,MAAvB,CAAf,CAZwB;;EAcxB,uBAAO/B,MAAP;EACD,eAfD;EAgBD,aAlBD,MAkBO,OAAOqC,OAAO,CAACX,GAAR,OAAAW,OAAO,EAAQC,SAAR,CAAd;EACR;EArB0B,SAAzB,CAAJ,CAFM;;EA0BNtB,QAAAA,CAAC,CAACF,IAAF,GAASA,IAAT;EACA,aAAKD,QAAL,CAAcoB,IAAd,CAAmBjB,CAAnB;EACA,aAAKK,UAAL,CAAgBkB,IAAhB,CAAqBvB,CAArB;EACD;;EACD,aAAOA,CAAP;EACD;EAED;;;;;;;;;;;;;;8BAWQF,MAAM;EACZ;EACA,UAAIA,IAAI,CAACP,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAvB,IAA4BO,IAAI,CAACP,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAvD,EAA0D;EACxD,eAAO,KAAKiC,OAAL,CAAa1B,IAAb,CAAP;EACD,OAJW;;;EAMZ,aAAO,KAAKQ,aAAL,CAAmBmB,IAAnB,CACL1B,gBAAM,CAAC,UAAA2B,GAAG;EAAA,eAAIrC,aAAa,CAACqC,GAAG,CAAC5B,IAAL,EAAWA,IAAX,CAAjB;EAAA,OAAJ,CADD,EAEL6B,kBAAQ,EAFH,CAAP;EAID;EAED;;;;;;;;;;;;;;;;;;;;qCAiBiD;EAAA,UAAvC9C,KAAuC,SAAvCA,KAAuC;EAAA,UAAhCsC,IAAgC,SAAhCA,IAAgC;EAAA,gCAA1B3C,OAA0B;EAAA,UAA1BA,OAA0B,8BAAhBoD,iBAAgB;EAC/C,UAAMC,IAAI,GAAG,KAAKzB,KAAL,CAAWR,iBAAX,CAA6B,KAAKC,QAAlC,EAA4ChB,KAA5C,CAAb;;EACA,UAAI,CAACgD,IAAL,EAAW;EACT,eAAOC,UAAP;EACD,OAJ8C;;;EAO/C,UAAMC,YAAY,GAAG,IAAIvD,OAAJ,EAArB;EACAqD,MAAAA,IAAI,CAACN,IAAL,CAAU;EAAEQ,QAAAA,YAAY,EAAZA,YAAF;EAAgBZ,QAAAA,IAAI,EAAJA;EAAhB,OAAV;EACA,aAAOY,YAAP;EACD;;;;;;EC3IH;;;;MAGMC;EACJ;;;;;;;;;EASA,kBAAc;EAAA;;EACZ;;;;;EAKA,SAAKC,QAAL,GAAgB,EAAhB;EACD;EAED;;;;;;;qCAGe;EACb,aAAOC,MAAM,CAACC,IAAP,CAAY,KAAKF,QAAjB,CAAP;EACD;EAED;;;;;;;;;;gCAOqC;EAAA,UAA7BnC,IAA6B,uEAAtB,oBAAsB;;EACnC,UAAI,CAAC,KAAKmC,QAAL,CAAcnC,IAAd,CAAL,EAA0B;EACxB,aAAKmC,QAAL,CAAcnC,IAAd,IAAsB,IAAIK,OAAJ,EAAtB;EACD;;EAED,aAAO,KAAK8B,QAAL,CAAcnC,IAAd,CAAP;EACD;;;;;;ACzCH,cAAe,IAAIsC,IAAJ,EAAf;;;;;;;;;;;;;;;"}