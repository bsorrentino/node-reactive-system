{"mappings":"IAWgCA,+BAAAA,sBAClBA,EAAEC,WAAaD,EAAEE,QAAUF,qBCL9B,MAAAG,EAEKC,UAAAA,IAAgBC,IAExBC,WAAeC,GACXC,EAAOC,IAAKC,KAAKN,UAAUO,IAAKJ,GAAAA,WAAmBA,yBAC/CK,EAAAA,IAAaC,SACjBH,KAAKN,UAAUU,IAAKP,EAAMK,GACnBA,EAGXG,QAAYR,UACRC,EAAOC,GAAIC,KAAKN,UAAUO,IAAKJ,GAAAA,WAAmBA,qBAE3CG,KAAKN,UAAUY,IAAKT,GAAQU,yCAI5BP,KAAKN,UAAUc,qBAKvB,MAAAC,EAEKC,SAAAA,IAAef,IAEvBgB,eAAgBC,GACZd,EAAOC,IAAKC,KAAKU,SAAST,IAAKW,EAAOf,MAAAA,UAAkBe,EAAOf,4BAE3DK,EAAAA,CACAU,OAAOA,EACPC,OAAAA,CAASC,SAAQ,EAAOC,QAAO,IAEnCf,KAAKU,SAASN,IAAKQ,EAAOf,KAAMK,GAC5BU,EAAOI,YACPJ,EAAOI,aAIfC,QACIjB,KAAKU,SAASQ,SAASC,IAEdA,EAAEN,OAAOC,UACNK,EAAEP,OAAOQ,SACTD,EAAEP,OAAOQ,UAEbD,EAAEN,OAAOC,SAAU,4BAM5B,MACMO,SAAAA,IAAiB5B,EACjB6B,QAAAA,IAAiBb,IAzDxBc,IAAAA,EAAAA,WA6DGC,EAAAA,IAAUD,EAAWE","sources":["../../node_modules/@parcel/scope-hoisting/lib/helpers.js","./src/rxbus.ts"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","import assert from 'assert'\nimport {MessageBus as bus} from '@soulsoftware/bus-core'\n\nimport { Observable, Subject } from 'rxjs'\n\nnamespace MessageBus {\n\n    export class Channels {\n    \n        private _channels = new Map<string,Subject<any>>()\n\n        newChannel<T>( name:string ):Subject<T> {\n            assert.ok( !this._channels.has( name ), `Channel ${name} already exists!` )\n            let result = new Subject<T>()\n            this._channels.set( name, result )\n            return result\n        }\n\n        channel<T>( name:string ):Observable<T> {\n            assert.ok( this._channels.has( name ), `Channel ${name} doesn't exists!` )\n            \n            return this._channels.get( name )!.asObservable()\n        }\n\n        get channelNames():IterableIterator<string> {\n            return this._channels.keys()\n        }\n    }\n    export type ModuleInfo = { module:bus.Module, status:bus.ModuleStatus }\n\n    export class Modules {\n    \n        private _modules = new Map<string,ModuleInfo>()\n\n        registerModule( module:bus.Module ) {\n            assert.ok( !this._modules.has( module.name ), `Module ${module.name} already exists!` )\n\n            let result:ModuleInfo = {\n                module:module,\n                status:{ started:false, paused:false} \n            }\n            this._modules.set( module.name, result )\n            if( module.onRegister ) {\n                module.onRegister()\n            }\n       }\n\n        start() {\n            this._modules.forEach( m => {\n\n                if( !m.status.started ) {\n                    if( m.module.onStart ) {\n                        m.module.onStart()\n                    }\n                    m.status.started = true\n                }\n            })\n        }\n    }\n\n    export class Engine {\n        readonly channels   = new Channels()\n        readonly modules    = new Modules()\n    }\n}\n\nexport const Bus = new MessageBus.Engine()\n\n/*\nexport function NewChannel(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const name = `_${propertyKey}`\n\n    Object.defineProperty( target, `_${propertyKey}`, {\n        writable: false,\n        value: new Subject<unknown>()\n    })\n\n    descriptor.get = () => target[name]\n    \n}\n\nexport function OnChannel(name: string) {\n\n    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n\n        Bus.channel( name ).subscribe( {Â next: descriptor.value } )\n        console.log( target, propertyKey, descriptor )\n    };\n  }\n*/\n"],"names":["a","__esModule","default","Channels","_channels","Map","newChannel","name","_assert","ok","this","has","result","Subject","set","channel","get","asObservable","keys","Modules","_modules","registerModule","module","status","started","paused","onRegister","start","forEach","m","onStart","channels","modules","$b0297db5b3f5685cf398a0d4463906b8$var$MessageBus","Bus","Engine"],"version":3,"file":"rxbus.js.map"}