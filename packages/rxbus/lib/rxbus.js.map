{"mappings":"IAWgCA,+BAAAA,sBAClBA,EAAEC,WAAaD,EAAEE,QAAUF,qBCLrC,MAAAG,EAEYC,UAAAA,IAAgBC,IAExBC,WAAeC,GACXC,EAAOC,IAAKC,KAAKN,UAAUO,IAAKJ,GAAAA,WAAmBA,yBAC/CK,EAAAA,IAAaC,SACjBH,KAAKN,UAAUU,IAAKP,EAAMK,GACnBA,EAGXG,QAAYR,UACRC,EAAOC,GAAIC,KAAKN,UAAUO,IAAKJ,GAAAA,WAAmBA,qBAE3CG,KAAKN,UAAUY,IAAKT,GAAQU,gBAK3C,MAAAC,EAEYC,SAAAA,IAAed,IAEvBe,eAAmBC,GACfb,EAAOC,IAAKC,KAAKS,SAASR,IAAKU,EAAOd,MAAAA,UAAkBc,EAAOd,4BAE3DK,EAAAA,CACAS,OAAOA,EACPC,OAAAA,CAASC,SAAQ,EAAOC,QAAO,IAEnCd,KAAKS,SAASL,IAAKO,EAAOd,KAAMK,GAGpCa,QACIf,KAAKS,SAASO,SAASC,IAEdA,EAAEL,OAAOC,UACNI,EAAEN,OAAOO,SACTD,EAAEN,OAAOO,UAEbD,EAAEL,OAAOC,SAAU,gBAM5B,MACHM,SAAAA,IAAe1B,EACf2B,QAAAA,IAAcZ,IAlDZa,IAAAA,EAAAA,WAsDGC,EAAAA,IAAUD,EAAWE,wCAG3B,SAAoBC,EAAaC,EAAqBC,SACnD7B,EAAAA,IAAW4B,IAEjBE,OAAOC,eAAgBJ,EAAAA,IAAYC,IAAY,CAC3CI,UAAU,EACVC,MAAAA,IAAW3B,IAGfuB,EAAWpB,IAAM,IAAMkB,EAAO3B,sBAI3B,SAAmBA,SAEf,CAAC2B,EAAaC,EAAqBC,KAEtCJ,EAAIjB,QAASR,GAAOkC,UAAAA,CAAaC,KAAMN,EAAWI,QAClDG,QAAQC,IAAKV,EAAQC,EAAaC","sources":["../../node_modules/@parcel/scope-hoisting/lib/helpers.js","./src/rxbus.ts"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","import assert from 'assert'\nimport * as bus from 'bus-module'\n\nimport { Observable, Subject } from 'rxjs'\n\nnamespace MessageBus {\n\n    class Channels {\n    \n        private _channels = new Map<string,Subject<any>>()\n\n        newChannel<T>( name:string ):Subject<T> {\n            assert.ok( !this._channels.has( name ), `Channel ${name} already exists!` )\n            let result = new Subject<T>()\n            this._channels.set( name, result )\n            return result\n        }\n\n        channel<T>( name:string ):Observable<T> {\n            assert.ok( this._channels.has( name ), `Channel ${name} doesn't exists!` )\n            \n            return this._channels.get( name )!.asObservable()\n        }\n    }\n    type ModuleInfo = { module:bus.Module, status:bus.ModuleStatus }\n\n    class Modules {\n    \n        private _modules = new Map<string,ModuleInfo>()\n\n        registerModule<T>( module:bus.Module ) {\n            assert.ok( !this._modules.has( module.name ), `Module ${module.name} already exists!` )\n\n            let result:ModuleInfo = {\n                module:module,\n                status:{ started:false, paused:false} \n            }\n            this._modules.set( module.name, result )\n        }\n\n        start() {\n            this._modules.forEach( m => {\n\n                if( !m.status.started ) {\n                    if( m.module.onStart ) {\n                        m.module.onStart()\n                    }\n                    m.status.started = true\n                }\n            })\n        }\n    }\n\n    export class Engine {\n        channels = new Channels()\n        modules = new Modules()\n    }\n}\n\nexport const Bus = new MessageBus.Engine()\n\n\nexport function NewChannel(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const name = `_${propertyKey}`\n\n    Object.defineProperty( target, `_${propertyKey}`, {\n        writable: false,\n        value: new Subject<unknown>()\n    })\n\n    descriptor.get = () => target[name]\n    \n}\n\nexport function OnChannel(name: string) {\n\n    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n\n        Bus.channel( name ).subscribe( {Â next: descriptor.value } )\n        console.log( target, propertyKey, descriptor )\n    };\n  }"],"names":["a","__esModule","default","Channels","_channels","Map","newChannel","name","_assert","ok","this","has","result","Subject","set","channel","get","asObservable","Modules","_modules","registerModule","module","status","started","paused","start","forEach","m","onStart","channels","modules","$b0297db5b3f5685cf398a0d4463906b8$var$MessageBus","Bus","Engine","target","propertyKey","descriptor","Object","defineProperty","writable","value","subscribe","next","console","log"],"version":3,"file":"rxbus.js.map"}